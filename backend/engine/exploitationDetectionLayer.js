const User = require('../models/User');
const CivilizationStabilityEngine = require('../models/CivilizationStabilityEngine');
const logger = require('../utils/logger');

class ExploitationDetectionLayer {
  constructor() {
    this.wealthInequalityThreshold = 0.6; // Gini coefficient threshold
    this.participationDropThreshold = 0.3; // 30% participation drop triggers alert
    this.whaleDominanceThreshold = 0.4; // 40% wealth by top 1% triggers alert
    this.botActivityThreshold = 0.2; // 20% estimated bot activity triggers alert
    this.extractionPressureThreshold = 0.5; // 50% extraction pressure triggers alert
  }

  // Monitor wealth inequality spikes
  async monitorWealthInequality() {
    try {
      const users = await User.find({});
      const balances = users.map(u => u.balance || 0);
      
      // Calculate Gini coefficient
      const sortedBalances = balances.sort((a, b) => a - b);
      let gini = 0;
      for (let i = 0; i < sortedBalances.length; i++) {
        gini += (2 * (i + 1) - sortedBalances.length - 1) * sortedBalances[i];
      }
      const totalBalance = balances.reduce((sum, balance) => sum + balance, 0);
      gini = totalBalance > 0 ? Math.abs(gini / (sortedBalances.length * totalBalance)) : 0;
      
      // Check for spike compared to historical data
      const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
      const previousGini = cse?.wealthInequalityGini || 0.3;
      const giniSpike = gini - previousGini;
      
      const alert = {
        metric: 'WEALTH_INEQUALITY',
        currentValue: gini,
        previousValue: previousGini,
        spike: giniSpike,
        threshold: this.wealthInequalityThreshold,
        isCritical: gini > this.wealthInequalityThreshold || giniSpike > 0.1,
        timestamp: Date.now()
      };
      
      if (alert.isCritical) {
        logger.warn(`Critical wealth inequality detected: Gini=${gini.toFixed(3)}, Spike=${giniSpike.toFixed(3)}`);
        await this.triggerExploitationAlert(alert);
      }
      
      return alert;
    } catch (error) {
      logger.error('Error monitoring wealth inequality:', error);
      throw error;
    }
  }

  // Monitor governance participation drop
  async monitorGovernanceParticipation() {
    try {
      const users = await User.find({});
      const activeUsers = users.filter(u => 
        u.lastActive && (Date.now() - u.lastActive) < 7 * 24 * 60 * 60 * 1000
      );
      
      const participatingUsers = activeUsers.filter(u => 
        u.governance && u.governance.participationScore > 0.5
      );
      
      const currentParticipationRate = activeUsers.length > 0 ? 
        participatingUsers.length / activeUsers.length : 0;
      
      // Check for drop compared to historical data
      const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
      const previousParticipation = cse?.participationRate || 0.6;
      const participationDrop = previousParticipation - currentParticipationRate;
      
      const alert = {
        metric: 'GOVERNANCE_PARTICIPATION',
        currentValue: currentParticipationRate,
        previousValue: previousParticipation,
        drop: participationDrop,
        threshold: this.participationDropThreshold,
        isCritical: participationDrop > this.participationDropThreshold,
        timestamp: Date.now()
      };
      
      if (alert.isCritical) {
        logger.warn(`Critical governance participation drop detected: ${currentParticipationRate.toFixed(3)}, Drop=${participationDrop.toFixed(3)}`);
        await this.triggerExploitationAlert(alert);
      }
      
      return alert;
    } catch (error) {
      logger.error('Error monitoring governance participation:', error);
      throw error;
    }
  }

  // Monitor whale dominance ratios
  async monitorWhaleDominance() {
    try {
      const users = await User.find({});
      const balances = users.map(u => u.balance || 0).sort((a, b) => b - a);
      
      const totalBalance = balances.reduce((sum, balance) => sum + balance, 0);
      const topOnePercentCount = Math.max(1, Math.floor(users.length * 0.01));
      const topOnePercentBalance = balances.slice(0, topOnePercentCount).reduce((sum, balance) => sum + balance, 0);
      
      const whaleDominanceRatio = totalBalance > 0 ? topOnePercentBalance / totalBalance : 0;
      
      // Check for increase compared to historical data
      const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
      const previousDominance = cse?.whaleDominanceRatio || 0.2;
      const dominanceIncrease = whaleDominanceRatio - previousDominance;
      
      const alert = {
        metric: 'WHALE_DOMINANCE',
        currentValue: whaleDominanceRatio,
        previousValue: previousDominance,
        increase: dominanceIncrease,
        threshold: this.whaleDominanceThreshold,
        isCritical: whaleDominanceRatio > this.whaleDominanceThreshold || dominanceIncrease > 0.1,
        timestamp: Date.now()
      };
      
      if (alert.isCritical) {
        logger.warn(`Critical whale dominance detected: ${whaleDominanceRatio.toFixed(3)}, Increase=${dominanceIncrease.toFixed(3)}`);
        await this.triggerExploitationAlert(alert);
      }
      
      return alert;
    } catch (error) {
      logger.error('Error monitoring whale dominance:', error);
      throw error;
    }
  }

  // Monitor bot-like behavior
  async monitorBotActivity() {
    try {
      const users = await User.find({});
      let botScore = 0;
      let totalUsers = users.length;
      
      for (const user of users) {
        const botSignals = await this.detectBotSignals(user);
        if (botSignals.length >= 3) { // Multiple signals indicate likely bot
          botScore += 1;
        }
      }
      
      const botActivityIndex = totalUsers > 0 ? botScore / totalUsers : 0;
      
      // Check for increase compared to historical data
      const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
      const previousBotActivity = cse?.botActivityIndex || 0.05;
      const botActivityIncrease = botActivityIndex - previousBotActivity;
      
      const alert = {
        metric: 'BOT_ACTIVITY',
        currentValue: botActivityIndex,
        previousValue: previousBotActivity,
        increase: botActivityIncrease,
        threshold: this.botActivityThreshold,
        isCritical: botActivityIndex > this.botActivityThreshold || botActivityIncrease > 0.05,
        timestamp: Date.now()
      };
      
      if (alert.isCritical) {
        logger.warn(`Critical bot activity detected: ${botActivityIndex.toFixed(3)}, Increase=${botActivityIncrease.toFixed(3)}`);
        await this.triggerExploitationAlert(alert);
      }
      
      return alert;
    } catch (error) {
      logger.error('Error monitoring bot activity:', error);
      throw error;
    }
  }

  // Detect bot signals for a user
  async detectBotSignals(user) {
    const signals = [];
    
    // Signal 1: 24/7 activity pattern
    if (user.activityPattern && user.activityPattern.length > 100) {
      const hourlyActivity = new Array(24).fill(0);
      user.activityPattern.forEach(timestamp => {
        const hour = new Date(timestamp).getHours();
        hourlyActivity[hour]++;
      });
      
      const variance = this.calculateVariance(hourlyActivity);
      const mean = hourlyActivity.reduce((sum, val) => sum + val, 0) / 24;
      const coefficientOfVariation = Math.sqrt(variance) / mean;
      
      if (coefficientOfVariation < 0.3) signals.push('24_7_ACTIVITY');
    }
    
    // Signal 2: Consistent action timing
    if (user.actionTiming && user.actionTiming.length > 10) {
      const intervals = [];
      for (let i = 1; i < user.actionTiming.length; i++) {
        intervals.push(user.actionTiming[i] - user.actionTiming[i - 1]);
      }
      
      const variance = this.calculateVariance(intervals);
      const mean = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
      const coefficientOfVariation = Math.sqrt(variance) / mean;
      
      if (coefficientOfVariation < 0.1) signals.push('CONSISTENT_TIMING');
    }
    
    // Signal 3: No natural breaks
    if (user.activityPattern && user.activityPattern.length > 50) {
      const hasNaturalBreaks = this.hasNaturalBreaks(user.activityPattern);
      if (!hasNaturalBreaks) signals.push('NO_NATURAL_BREAKS');
    }
    
    // Signal 4: Identical action patterns
    if (user.actionPatterns && user.actionPatterns.length > 5) {
      const patternVariety = new Set(user.actionPatterns).size;
      if (patternVariety < 3) signals.push('IDENTICAL_PATTERNS');
    }
    
    // Signal 5: Instant responses
    if (user.responseTimes && user.responseTimes.length > 5) {
      const avgResponseTime = user.responseTimes.reduce((sum, time) => sum + time, 0) / user.responseTimes.length;
      if (avgResponseTime < 100) signals.push('INSTANT_RESPONSES'); // <100ms average
    }
    
    return signals;
  }

  // Calculate overall extraction pressure
  async calculateExtractionPressure() {
    try {
      const metrics = await Promise.all([
        this.monitorWealthInequality(),
        this.monitorGovernanceParticipation(),
        this.monitorWhaleDominance(),
        this.monitorBotActivity()
      ]);
      
      // Weight the different metrics
      const weights = {
        WEALTH_INEQUALITY: 0.3,
        GOVERNANCE_PARTICIPATION: 0.2,
        WHALE_DOMINANCE: 0.3,
        BOT_ACTIVITY: 0.2
      };
      
      let extractionPressure = 0;
      metrics.forEach(metric => {
        const weight = weights[metric.metric];
        const value = metric.isCritical ? 1 : metric.currentValue / metric.threshold;
        extractionPressure += value * weight;
      });
      
      // Check for increase compared to historical data
      const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
      const previousExtraction = cse?.extractionPressure || 0.1;
      const extractionIncrease = extractionPressure - previousExtraction;
      
      const alert = {
        metric: 'EXTRACTION_PRESSURE',
        currentValue: extractionPressure,
        previousValue: previousExtraction,
        increase: extractionIncrease,
        threshold: this.extractionPressureThreshold,
        isCritical: extractionPressure > this.extractionPressureThreshold,
        timestamp: Date.now(),
        components: metrics
      };
      
      if (alert.isCritical) {
        logger.warn(`Critical extraction pressure detected: ${extractionPressure.toFixed(3)}, Increase=${extractionIncrease.toFixed(3)}`);
        await this.triggerExploitationAlert(alert);
      }
      
      return alert;
    } catch (error) {
      logger.error('Error calculating extraction pressure:', error);
      throw error;
    }
  }

  // Trigger exploitation alert
  async triggerExploitationAlert(alert) {
    try {
      const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
      if (!cse) {
        logger.warn('No CSE instance found for alert triggering');
        return;
      }
      
      // Check if alert already exists
      const existingAlert = cse.alerts.find(a => 
        a.metric === alert.metric && 
        !a.resolved &&
        (Date.now() - a.timestamp) < 24 * 60 * 60 * 1000 // Within last 24 hours
      );
      
      if (existingAlert) {
        // Update existing alert
        existingAlert.value = alert.currentValue;
        existingAlert.timestamp = alert.timestamp;
      } else {
        // Create new alert
        cse.alerts.push({
          type: alert.isCritical ? 'CRITICAL' : 'WARNING',
          message: `Exploitation detected: ${alert.metric} = ${alert.currentValue.toFixed(3)}`,
          metric: alert.metric,
          value: alert.currentValue,
          threshold: alert.threshold,
          timestamp: alert.timestamp,
          actions: this.getRecommendedActions(alert)
        });
      }
      
      await cse.save();
    } catch (error) {
      logger.error('Error triggering exploitation alert:', error);
    }
  }

  // Get recommended actions for an alert
  getRecommendedActions(alert) {
    const actions = [];
    
    switch (alert.metric) {
      case 'WEALTH_INEQUALITY':
        actions.push('ACTIVATE_ECONOMIC_SHOCK_ABSORBER');
        actions.push('INCREASE_ANTI_HOARDING_TAX');
        actions.push('REDISTRIBUTION_MECHANISM');
        break;
        
      case 'GOVERNANCE_PARTICIPATION':
        actions.push('ACTIVATE_GOVERNANCE_FEEDBACK');
        actions.push('MICRO_GOVERNANCE_EVENTS');
        actions.push('PARTICIPATION_REWARDS');
        break;
        
      case 'WHALE_DOMINANCE':
        actions.push('ACTIVATE_POWER_DIFFUSION');
        actions.push('AUTHORITY_DECAY_ACCELERATION');
        actions.push('CITIZEN_JURY_SUMMONING');
        break;
        
      case 'BOT_ACTIVITY':
        actions.push('ACTIVATE_IMMUNE_SYSTEM');
        actions.push('CAPTCHA_IMPLEMENTATION');
        actions.push('BEHAVIORAL_VERIFICATION');
        break;
        
      case 'EXTRACTION_PRESSURE':
        actions.push('MULTI_LAYER_STABILIZATION');
        actions.push('EMERGENCY_PROTOCOLS');
        actions.push('COMMUNITY_ALERTS');
        break;
    }
    
    return actions;
  }

  // Run comprehensive exploitation detection
  async runExploitationDetection() {
    try {
      logger.info('Starting comprehensive exploitation detection...');
      
      const results = await Promise.all([
        this.monitorWealthInequality(),
        this.monitorGovernanceParticipation(),
        this.monitorWhaleDominance(),
        this.monitorBotActivity(),
        this.calculateExtractionPressure()
      ]);
      
      const criticalAlerts = results.filter(r => r.isCritical);
      
      if (criticalAlerts.length > 0) {
        logger.warn(`Exploitation detection complete: ${criticalAlerts.length} critical alerts found`);
        
        // Trigger auto-correction if enabled
        const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
        if (cse && cse.autoCorrectionEnabled) {
          await this.triggerAutoCorrection(criticalAlerts);
        }
      } else {
        logger.info('Exploitation detection complete: No critical alerts');
      }
      
      return {
        timestamp: Date.now(),
        totalAlerts: results.length,
        criticalAlerts: criticalAlerts.length,
        results
      };
    } catch (error) {
      logger.error('Error in comprehensive exploitation detection:', error);
      throw error;
    }
  }

  // Trigger auto-correction for critical alerts
  async triggerAutoCorrection(alerts) {
    try {
      logger.info(`Triggering auto-correction for ${alerts.length} critical alerts`);
      
      for (const alert of alerts) {
        const actions = this.getRecommendedActions(alert);
        
        for (const action of actions) {
          // This would interface with the appropriate stabilizer
          logger.info(`Auto-correction triggered: ${action} for ${alert.metric}`);
          
          // Activate stabilizer
          const cse = await CivilizationStabilityEngine.findOne().sort({ createdAt: -1 });
          if (cse) {
            const stabilizerType = action.replace('ACTIVATE_', '').replace('_MECHANISM', '').replace('_PROTOCOLS', '');
            
            const existingStabilizer = cse.activeStabilizers.find(s => s.type === stabilizerType);
            if (existingStabilizer) {
              existingStabilizer.activated = Date.now();
            } else {
              cse.activeStabilizers.push({
                type: stabilizerType,
                activated: Date.now(),
                effectiveness: 0,
                parameters: this.getStabilizerParameters(stabilizerType, alert)
              });
            }
            
            await cse.save();
          }
        }
      }
    } catch (error) {
      logger.error('Error triggering auto-correction:', error);
    }
  }

  // Get stabilizer parameters based on alert
  getStabilizerParameters(stabilizerType, alert) {
    const baseParams = {
      triggeredBy: alert.metric,
      severity: alert.isCritical ? 'HIGH' : 'MEDIUM',
      timestamp: Date.now()
    };
    
    switch (stabilizerType) {
      case 'ECONOMIC_SHOCK_ABSORBER':
        return {
          ...baseParams,
          antiHoardingTax: 0.15,
          redistributionRate: 0.1,
          treasuryInjection: true
        };
        
      case 'GOVERNANCE_FEEDBACK':
        return {
          ...baseParams,
          microGovernanceFrequency: 'daily',
          sentimentMapping: true,
          participatoryRewards: 0.3
        };
        
      case 'POWER_DIFFUSION':
        return {
          ...baseParams,
          authorityDecayMultiplier: 2.0,
          councilRotation: true,
          citizenJuryProbability: 0.2
        };
        
      case 'IMMUNE_SYSTEM':
        return {
          ...baseParams,
          autonomousAgents: true,
          preEmptiveDetection: true,
          neutralizationProtocol: 'automatic'
        };
        
      default:
        return baseParams;
    }
  }

  // Helper: Calculate variance
  calculateVariance(values) {
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
  }

  // Helper: Check for natural breaks
  hasNaturalBreaks(activityPattern) {
    for (let i = 1; i < activityPattern.length; i++) {
      const gap = activityPattern[i] - activityPattern[i - 1];
      if (gap > 6 * 60 * 60 * 1000) return true; // 6+ hour gap
    }
    return false;
  }

  // Get exploitation metrics
  async getExploitationMetrics() {
    try {
      const results = await Promise.all([
        this.monitorWealthInequality(),
        this.monitorGovernanceParticipation(),
        this.monitorWhaleDominance(),
        this.monitorBotActivity(),
        this.calculateExtractionPressure()
      ]);
      
      return {
        extractionPressure: results.find(r => r.metric === 'EXTRACTION_PRESSURE')?.currentValue || 0,
        whaleDominanceRatio: results.find(r => r.metric === 'WHALE_DOMINANCE')?.currentValue || 0,
        botActivityIndex: results.find(r => r.metric === 'BOT_ACTIVITY')?.currentValue || 0,
        wealthInequalityGini: results.find(r => r.metric === 'WEALTH_INEQUALITY')?.currentValue || 0,
        governanceParticipationDrop: results.find(r => r.metric === 'GOVERNANCE_PARTICIPATION')?.drop || 0,
        criticalAlerts: results.filter(r => r.isCritical).length,
        totalAlerts: results.length
      };
    } catch (error) {
      logger.error('Error getting exploitation metrics:', error);
      throw error;
    }
  }
}

module.exports = ExploitationDetectionLayer;
